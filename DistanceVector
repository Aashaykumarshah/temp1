#!/usr/bin/env python3
import sys
import math

INF = math.inf

def parse_input():
    nodes = []
    for line in sys.stdin:
        tok = line.strip()
        if not tok:
            continue
        if tok == "START":
            break
        nodes.append(tok)

    edges = []
    for line in sys.stdin:
        tok = line.strip()
        if not tok:
            continue
        if tok == "UPDATE":
            break
        u, v, w = tok.split()
        w = int(w)
        if w < 0:
            print(f"Ignoring invalid initial link with negative weight: {u} {v} {w}")
            continue
        edges.append((u, v, w))

    updates = []
    for line in sys.stdin:
        tok = line.strip()
        if not tok:
            continue
        if tok == "END":
            break
        u, v, w = tok.split()
        updates.append((u, v, int(w)))

    return nodes, edges, updates


def run_dv(nodes, edges, start_time):
    graph = {n: {} for n in nodes}
    for u, v, w in edges:
        graph[u][v] = w
        graph[v][u] = w

    dt = {}
    for x in nodes:
        dt[x] = {}
        for dest in nodes:
            if dest == x:
                continue
            dt[x][dest] = {via: INF for via in nodes if via != x}
        for nbr, w in graph[x].items():
            if nbr not in dt[x]:
                dt[x][nbr] = {via: INF for via in nodes if via != x}
            dt[x][nbr][nbr] = w

    t = start_time
    print_distance_tables(nodes, dt, t)
    t += 1

    while True:
        # Flat adv map with poison reverse
        adv = {src: {nbr: {} for nbr in graph[src]} for src in nodes}
        for src in nodes:
            for dest in nodes:
                if dest == src:
                    continue
                best_via, best_cost = min(dt[src][dest].items(), key=lambda kv: kv[1])
                for nbr in graph[src]:
                    if best_via == nbr:
                        adv[src][nbr][dest] = INF
                    else:
                        adv[src][nbr][dest] = best_cost

        updated = False
        for x in nodes:
            for nbr, cost_x_nbr in graph[x].items():
                for dest in dt[x]:
                    if dest == x:
                        continue
                    adv_cost = adv[nbr][x].get(dest, INF)
                    if adv_cost == INF:
                        continue
                    nc = cost_x_nbr + adv_cost
                    if nc < dt[x][dest][nbr]:
                        dt[x][dest][nbr] = nc
                        updated = True


        if not updated:
            break

        print_distance_tables(nodes, dt, t)
        t += 1

    print_routing_tables(nodes, dt)
    return t


def print_distance_tables(nodes, dt, t):
    for x in sorted(nodes):
        print(f"Distance Table of router {x} at t={t}:")
        others = [n for n in sorted(nodes) if n != x]
        print("   " + " ".join(others))
        for dest in others:
            row = [dest]
            for via in others:
                c = dt[x][dest][via]
                row.append(str(int(c)) if c != INF else "INF")
            print("   " + " ".join(row))
        print()

def print_routing_tables(nodes, dt):
    for x in sorted(nodes):
        print(f"Routing Table of router {x}:")
        for dest in sorted(nodes):
            if dest == x:
                continue
            via, cost = min(dt[x][dest].items(), key=lambda kv: kv[1])
            if cost == INF:
                print(f"{dest},INF,INF")
            else:
                print(f"{dest},{via},{int(cost)}")
        print()

def main():
    nodes, edges, updates = parse_input()

    # Ensure unique sorted node list from all edge info
    nodes = sorted(set(nodes + [n for e in edges for n in e[:2]]))

    t = 0
    t = run_dv(nodes, edges, t)

    if updates:
        # Apply updates to edges
        for u, v, w in updates:
            if w < 0:
                 print(f"Ignoring invalid negative weight: {u} {v} {w}")
                 continue
            # Remove old u-v links
            edges = [e for e in edges if not ((e[0] == u and e[1] == v) or (e[0] == v and e[1] == u))]
            edges.append((u, v, w))

        # Refresh node list from updated edge list
        nodes = sorted(set(n for e in edges for n in e[:2]))

        # Run updated topology
        t = 0
        t = run_dv(nodes, edges, t)

if __name__ == "__main__":
    main()
