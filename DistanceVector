#!/usr/bin/env python3
import sys
import math

INF = math.inf

def parse_input():
    nodes, edges, updates = [], [], []
    try:
        while True:
            line = input().strip()
            if line == "START":
                break
            if line:
                nodes.append(line)

        while True:
            line = input().strip()
            if line == "UPDATE":
                break
            if line:
                u, v, w = line.split()
                edges.append((u, v, int(w)))

        while True:
            line = input().strip()
            if line == "END":
                break
            if line:
                u, v, w = line.split()
                updates.append((u, v, int(w)))

    except EOFError:
        pass

    return nodes, edges, updates

def run_dv(nodes, edges, start_time):
    graph = {n: {} for n in nodes}
    for u, v, w in edges:
        graph.setdefault(u, {})[v] = w
        graph.setdefault(v, {})[u] = w

    dt = {}
    for x in nodes:
        dt[x] = {}
        for dest in nodes:
            if dest == x:
                continue
            dt[x][dest] = { via: INF for via in nodes if via != x }
        for nbr, w in graph[x].items():
            if nbr in dt[x]:
                dt[x][nbr][nbr] = w

    t = start_time
    print_distance_tables(nodes, dt, t)
    t += 1

    while True:
        adv = {src: {dst: (0 if src == dst else min(dt[src][dst].values())) for dst in nodes} for src in nodes}
        updated = False

        for x in nodes:
            for src, cost_x_src in graph[x].items():
                for dest in dt[x]:
                    nc = cost_x_src + adv[src][dest]
                    if nc < dt[x][dest][src]:
                        dt[x][dest][src] = nc
                        updated = True

        if not updated:
            break

        print_distance_tables(nodes, dt, t)
        t += 1

    print_routing_tables(nodes, dt)
    return t

def print_distance_tables(nodes, dt, t):
    for x in sorted(nodes):
        print(f"Distance Table of router {x} at t={t}:")
        others = [n for n in sorted(nodes) if n != x]
        header = "     " + "   ".join(f"{n:<4}" for n in others)
        print(header)
        for dest in others:
            row = f"{dest:<5}"
            for via in others:
                cost = dt[x][dest][via]
                row += f"{int(cost):>5}" if cost != INF else "  INF"
            print("     " + row)
        print()

def print_routing_tables(nodes, dt):
    for x in sorted(nodes):
        print(f"Routing Table of router {x}:")
        for dest in sorted(nodes):
            if dest == x:
                continue
            best_cost = INF
            best_via = None
            for via in sorted(dt[x][dest].keys()):
                cost = dt[x][dest][via]
                if cost < best_cost:
                    best_cost = cost
                    best_via = via
            if best_cost == INF:
                print(f"{dest},INF,INF")
            else:
                print(f"{dest},{best_via},{int(best_cost)}")
        print("")  # precise single blank line after each routing table

def main():
    t = 0
    nodes_seen = set()
    edges = []

    while True:
        try:
            nodes, new_edges, updates = parse_input()
        except EOFError:
            break

        if not nodes:
            break

        for n in nodes:
            if n not in nodes_seen:
                nodes_seen.add(n)

        edges = [e for e in edges if e[0] in nodes_seen and e[1] in nodes_seen]
        for e in new_edges:
            edges.append(e)

        t = run_dv(sorted(nodes_seen), edges, t)

        if updates:
            for u, v, w in updates:
                edges = [e for e in edges if not ((e[0] == u and e[1] == v) or (e[0] == v and e[1] == u))]
                if w >= 0:
                    edges.append((u, v, w))
                nodes_seen.update([u, v])

            t = run_dv(sorted(nodes_seen), edges, t)

if __name__ == "__main__":
    main()
